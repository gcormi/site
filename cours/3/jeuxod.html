<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeux Sérieux - Objets Domestiques Technologiques</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #3498DB;        /* Bleu clair */
            --secondary: #2ECC71;      /* Vert */
            --dark: #2C3E50;           /* Bleu foncé */
            --light: #ECF0F1;          /* Gris clair */
            --accent: #E74C3C;         /* Rouge */
            --white: #FFFFFF;          /* Blanc */
            --yellow: #F1C40F;         /* Jaune */
            --purple: #9B59B6;         /* Violet */
            --orange: #FF9800;         /* Orange */
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.1); /* Ombre légère */
            --rounded: 12px;           /* Bordures arrondies */
        }

        body {
            font-family: 'Open Sans', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--light);
            color: var(--dark);
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode {
            background-color: #1a1a2e;
            color: #e6e6e6;
        }

        header {
            background-color: var(--primary);
            color: white;
            padding: 1rem 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .dark-mode header {
            background-color: #111827;
        }

        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px 0;
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-links {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 30px;
            transition: background-color 0.3s;
            font-weight: 600;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .nav-link:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .nav-link.active {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .dark-toggle {
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            padding: 10px;
            font-size: 1.2rem;
            border-radius: 50%;
            transition: background-color 0.3s;
        }

        .dark-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        h1, h2, h3 {
            font-family: 'Montserrat', sans-serif;
            margin-top: 0;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.8rem;
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
            padding-bottom: 8px;
            margin-bottom: 20px;
        }

        .dark-mode h2 {
            color: var(--light);
            border-bottom-color: var(--light);
        }

        .game-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .object-tab {
            padding: 10px 20px;
            background-color: var(--primary);
            color: white;
            border-radius: var(--rounded);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .object-tab:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow);
        }

        .object-tab.active {
            background-color: var(--secondary);
        }

        .game-type-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .game-type {
            padding: 8px 16px;
            background-color: var(--white);
            color: var(--dark);
            border-radius: var(--rounded);
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }

        .dark-mode .game-type {
            background-color: #2d3748;
            color: var(--light);
        }

        .game-type:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .game-type.active {
            background-color: var(--secondary);
            color: white;
        }

        .game-container {
            background-color: var(--white);
            border-radius: var(--rounded);
            padding: 30px;
            box-shadow: var(--shadow);
            margin-bottom: 40px;
            min-height: 400px;
        }

        .dark-mode .game-container {
            background-color: #2d3748;
        }

        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        .game-section {
            display: none;
        }

        .game-section.active {
            display: block;
        }

        /* Styles des jeux */
        /* Quiz */
        .quiz-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .question {
            margin-bottom: 20px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option {
            padding: 15px;
            background-color: var(--light);
            border-radius: var(--rounded);
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .dark-mode .option {
            background-color: #384152;
        }

        .option:hover {
            background-color: #dfe6e9;
        }

        .dark-mode .option:hover {
            background-color: #4a5568;
        }

        .option.selected {
            background-color: var(--primary);
            color: white;
        }

        .option.correct {
            background-color: var(--secondary);
            color: white;
        }

        .option.incorrect {
            background-color: var(--accent);
            color: white;
        }

        .quiz-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        /* Association */
        .association-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }

        .term-card, .definition-card {
            width: 200px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 10px;
            border-radius: var(--rounded);
            background-color: var(--light);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .dark-mode .term-card, .dark-mode .definition-card {
            background-color: #384152;
        }

        .term-card {
            border: 2px solid var(--primary);
        }

        .definition-card {
            border: 2px solid var(--secondary);
        }

        .term-card.selected, .definition-card.selected {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .term-card.matched, .definition-card.matched {
            background-color: #dff0d8;
            border-color: var(--secondary);
            cursor: default;
        }

        .dark-mode .term-card.matched, .dark-mode .definition-card.matched {
            background-color: #2d4b37;
        }

        /* Pendu */
        .hangman-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .hangman-word {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .hangman-letter {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 3px solid var(--dark);
            font-size: 1.5rem;
            font-weight: bold;
        }

        .dark-mode .hangman-letter {
            border-bottom-color: var(--light);
        }

        .hangman-drawing {
            width: 200px;
            height: 250px;
            position: relative;
            margin-bottom: 20px;
        }

        .hangman-keyboard {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 500px;
        }

        .keyboard-key {
            padding: 10px;
            background-color: var(--light);
            color: var(--dark);
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
        }

        .dark-mode .keyboard-key {
            background-color: #384152;
            color: var(--light);
        }

        .keyboard-key:hover {
            background-color: var(--primary);
            color: white;
        }

        .keyboard-key.used {
            background-color: #b2bec3;
            cursor: default;
            color: #636e72;
        }

        .dark-mode .keyboard-key.used {
            background-color: #4a5568;
            color: #a0aec0;
        }

        /* Memory */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 10px;
            margin: 0 auto;
            max-width: 600px;
        }

        .memory-card {
            aspect-ratio: 1;
            background-color: var(--primary);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 0.5s;
            font-weight: bold;
            color: white;
        }

        .memory-card.flipped {
            transform: rotateY(180deg);
        }

        .memory-card .front,
        .memory-card .back {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
            text-align: center;
        }

        .memory-card .front {
            background-color: var(--primary);
            transform: rotateY(180deg);
        }

        .memory-card .back {
            background-color: var(--dark);
            color: white;
            font-size: 1.5rem;
        }

        /* Mots mêlés */
        .wordsearch-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .wordsearch-grid {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 2px;
            margin: 0 auto;
            max-width: 600px;
        }

        .wordsearch-cell {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--light);
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .dark-mode .wordsearch-cell {
            background-color: #384152;
        }

        .wordsearch-cell:hover {
            background-color: #dfe6e9;
        }

        .dark-mode .wordsearch-cell:hover {
            background-color: #4a5568;
        }

        .wordsearch-cell.selected {
            background-color: var(--primary);
            color: white;
        }

        .wordsearch-cell.found {
            background-color: var(--secondary);
            color: white;
        }

        .wordsearch-words {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .wordsearch-word {
            padding: 8px 16px;
            background-color: var(--light);
            border-radius: 20px;
            transition: all 0.2s;
        }

        .dark-mode .wordsearch-word {
            background-color: #384152;
        }

        .wordsearch-word.found {
            background-color: var(--secondary);
            color: white;
            text-decoration: line-through;
        }
        
        /* Classification */
        .classification-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .classification-categories {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .classification-category {
            background-color: var(--light);
            padding: 15px;
            border-radius: var(--rounded);
            width: 30%;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            box-shadow: var(--shadow);
        }
        
        .dark-mode .classification-category {
            background-color: #384152;
        }
        
        .classification-category-title {
            font-weight: 700;
            text-align: center;
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        .dark-mode .classification-category-title {
            color: var(--light);
        }
        
        .classification-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .classification-item {
            background-color: var(--white);
            color: var(--dark);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .dark-mode .classification-item {
            background-color: #2d3748;
            color: var(--light);
        }
        
        .classification-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .classification-item.dragging {
            opacity: 0.5;
        }
        
        .classification-category.highlight {
            background-color: rgba(46, 204, 113, 0.2);
        }
        
        .dark-mode .classification-category.highlight {
            background-color: rgba(46, 204, 113, 0.3);
        }
        
        .classification-item.placed {
            margin: 5px 0;
        }
        
        /* Chaînes */
        .chaines-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .chaine-diagram {
            width: 100%;
            max-width: 800px;
            padding: 20px;
            background-color: var(--light);
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
        }
        
        .dark-mode .chaine-diagram {
            background-color: #384152;
        }
        
        .chaine-title {
            text-align: center;
            margin-bottom: 15px;
            color: var(--primary);
            font-weight: 700;
        }
        
        .dark-mode .chaine-title {
            color: var(--light);
        }
        
        .chaine-blocks {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
        }
        
        .chaine-block {
            width: 150px;
            height: 80px;
            background-color: var(--white);
            border: 2px solid var(--primary);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 10px;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .dark-mode .chaine-block {
            background-color: #2d3748;
            color: var(--light);
        }
        
        .chaine-block:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }
        
        .chaine-block.highlight {
            border-color: var(--secondary);
            background-color: rgba(46, 204, 113, 0.1);
        }
        
        .dark-mode .chaine-block.highlight {
            background-color: rgba(46, 204, 113, 0.2);
        }
        
        .chaine-arrow {
            flex: 1;
            height: 3px;
            background-color: var(--dark);
            position: relative;
            margin: 0 10px;
        }
        
        .dark-mode .chaine-arrow {
            background-color: var(--light);
        }
        
        .chaine-arrow::after {
            content: '';
            position: absolute;
            right: 0;
            top: -5px;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 10px solid var(--dark);
        }
        
        .dark-mode .chaine-arrow::after {
            border-left-color: var(--light);
        }
        
        .chaine-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        
        .chaine-option {
            background-color: var(--white);
            color: var(--dark);
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }
        
        .dark-mode .chaine-option {
            background-color: #2d3748;
            color: var(--light);
        }
        
        .chaine-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .chaine-option.used {
            opacity: 0.5;
            cursor: default;
        }
        
        /* Bouton et styles communs */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--rounded);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .progress-container {
            width: 100%;
            height: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .dark-mode .progress-container {
            background-color: #4a5568;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--secondary);
            border-radius: 5px;
            width: 0;
            transition: width 0.3s ease;
        }
        
        .score-display {
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            margin-top: 15px;
            color: var(--primary);
        }
        
        .dark-mode .score-display {
            color: var(--light);
        }
        
        .success-message {
            background-color: rgba(46, 204, 113, 0.2);
            padding: 15px;
            border-radius: var(--rounded);
            text-align: center;
            margin: 20px 0;
            font-weight: 600;
            color: #27ae60;
        }
        
        .dark-mode .success-message {
            background-color: rgba(46, 204, 113, 0.3);
            color: #2ecc71;
        }
        
        .badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-left: 10px;
            background-color: var(--accent);
            color: white;
        }
        
        /* Adaptabilité mobile */
        @media (max-width: 768px) {
            .container {
                width: 95%;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .game-type-selector {
                gap: 10px;
            }
            
            .game-type {
                padding: 6px 12px;
                font-size: 0.9rem;
            }
            
            .classification-categories {
                flex-direction: column;
                align-items: center;
            }
            
            .classification-category {
                width: 90%;
                margin-bottom: 15px;
            }
            
            .memory-grid {
                grid-template-columns: repeat(4, 1fr);
                grid-template-rows: repeat(9, 1fr);
            }
            
            .wordsearch-cell {
                width: 25px;
                height: 25px;
                font-size: 0.8rem;
            }
            
            .hangman-letter {
                width: 30px;
                height: 30px;
                font-size: 1.2rem;
            }
            
            .chaine-blocks {
                flex-direction: column;
                gap: 20px;
            }
            
            .chaine-arrow {
                width: 3px;
                height: 30px;
                margin: 0;
            }
            
            .chaine-arrow::after {
                right: -5px;
                top: auto;
                bottom: 0;
                transform: rotate(90deg);
            }
        }
        
        @media (max-width: 480px) {
            .wordsearch-cell {
                width: 20px;
                height: 20px;
                font-size: 0.7rem;
            }
            
            .memory-card {
                font-size: 0.8rem;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="container">
            <nav>
                <h1>Jeux Éducatifs</h1>
                <div class="nav-links">
                    <span id="currentGameLabel" class="nav-link active">Jeux Éducatifs</span>
                    <button class="dark-toggle" title="Changer de mode">
                        <i class="fas fa-moon"></i>
                    </button>
                </div>
            </nav>
        </div>
    </header>

    <main class="container">
        <div class="game-selector">
            <div class="object-tab active" data-object="eolienne">Éoliennes</div>
            <div class="object-tab" data-object="fauteuil">Fauteuils Électriques</div>
            <div class="object-tab" data-object="montre">Montres Connectées</div>
        </div>

        <div class="game-type-selector">
            <div class="game-type active" data-game="quiz">Quiz</div>
            <div class="game-type" data-game="association">Association</div>
            <div class="game-type" data-game="pendu">Jeu du Pendu</div>
            <div class="game-type" data-game="memory">Memory</div>
            <div class="game-type" data-game="wordsearch">Mots Mêlés</div>
            <div class="game-type" data-game="classification">Classification</div>
            <div class="game-type" data-game="chaines">Chaînes</div>
        </div>

        <div class="game-container">
            <!-- Sections pour les éoliennes -->
            <div id="eolienne-content" class="content-section active">
                <div id="eolienne-quiz" class="game-section active">
                    <h2>Quiz - Éoliennes</h2>
                    <div class="quiz-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="eolienne-association" class="game-section">
                    <h2>Association - Éoliennes</h2>
                    <div class="association-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="eolienne-pendu" class="game-section">
                    <h2>Jeu du Pendu - Éoliennes</h2>
                    <div class="hangman-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="eolienne-memory" class="game-section">
                    <h2>Memory - Éoliennes</h2>
                    <div class="memory-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="eolienne-wordsearch" class="game-section">
                    <h2>Mots Mêlés - Éoliennes</h2>
                    <div class="wordsearch-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="eolienne-classification" class="game-section">
                    <h2>Classification - Éoliennes</h2>
                    <div class="classification-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="eolienne-chaines" class="game-section">
                    <h2>Chaînes - Éoliennes</h2>
                    <div class="chaines-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
            </div>
            
            <!-- Sections pour les fauteuils électriques -->
            <div id="fauteuil-content" class="content-section">
                <div id="fauteuil-quiz" class="game-section active">
                    <h2>Quiz - Fauteuils Électriques</h2>
                    <div class="quiz-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="fauteuil-association" class="game-section">
                    <h2>Association - Fauteuils Électriques</h2>
                    <div class="association-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="fauteuil-pendu" class="game-section">
                    <h2>Jeu du Pendu - Fauteuils Électriques</h2>
                    <div class="hangman-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="fauteuil-memory" class="game-section">
                    <h2>Memory - Fauteuils Électriques</h2>
                    <div class="memory-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="fauteuil-wordsearch" class="game-section">
                    <h2>Mots Mêlés - Fauteuils Électriques</h2>
                    <div class="wordsearch-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="fauteuil-classification" class="game-section">
                    <h2>Classification - Fauteuils Électriques</h2>
                    <div class="classification-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="fauteuil-chaines" class="game-section">
                    <h2>Chaînes - Fauteuils Électriques</h2>
                    <div class="chaines-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
            </div>
            
            <!-- Sections pour les montres connectées -->
            <div id="montre-content" class="content-section">
                <div id="montre-quiz" class="game-section active">
                    <h2>Quiz - Montres Connectées</h2>
                    <div class="quiz-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="montre-association" class="game-section">
                    <h2>Association - Montres Connectées</h2>
                    <div class="association-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="montre-pendu" class="game-section">
                    <h2>Jeu du Pendu - Montres Connectées</h2>
                    <div class="hangman-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="montre-memory" class="game-section">
                    <h2>Memory - Montres Connectées</h2>
                    <div class="memory-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="montre-wordsearch" class="game-section">
                    <h2>Mots Mêlés - Montres Connectées</h2>
                    <div class="wordsearch-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="montre-classification" class="game-section">
                    <h2>Classification - Montres Connectées</h2>
                    <div class="classification-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
                
                <div id="montre-chaines" class="game-section">
                    <h2>Chaînes - Montres Connectées</h2>
                    <div class="chaines-container">
                        <!-- Le contenu sera généré par JavaScript -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="progress-container">
            <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
        </div>
        
        <div class="success-message" style="display: none;">
            Félicitations ! Vous avez complété ce jeu. Passez au suivant pour continuer votre apprentissage.
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
            <button id="reset-button" class="btn btn-primary">Remise à zéro</button>
        </div>
    </main>

    <script>
        const gameData = {
            eolienne: {
                // Classification pour les éoliennes
                classification: [
                    {
                        categories: ["Composants structurels", "Composants électriques", "Éléments de captation"],
                        items: [
                            { name: "Mât", category: "Composants structurels" },
                            { name: "Nacelle", category: "Composants structurels" },
                            { name: "Pales", category: "Éléments de captation" },
                            { name: "Rotor", category: "Éléments de captation" },
                            { name: "Alternateur", category: "Composants électriques" },
                            { name: "Transformateur", category: "Composants électriques" },
                            { name: "Girouette", category: "Éléments de captation" },
                            { name: "Anémomètre", category: "Éléments de captation" },
                            { name: "Multiplicateur", category: "Composants électriques" },
                            { name: "Fondation", category: "Composants structurels" },
                            { name: "Système d'orientation", category: "Composants structurels" },
                            { name: "Onduleur", category: "Composants électriques" }
                        ]
                    }
                ],
                // Chaînes d'énergie et d'information pour les éoliennes
                chaines: [
                    {
                        energie: [
                            "Vent",
                            "Rotation des pales",
                            "Transmission mécanique",
                            "Génération électrique",
                            "Distribution réseau"
                        ],
                        information: [
                            "Capteurs",
                            "Traitement données",
                            "Commande d'orientation",
                            "Régulation puissance",
                            "Surveillance système"
                        ]
                    }
                ],
                // Quiz pour les éoliennes
                quiz: [
                    {
                        title: "Quiz sur les éoliennes - Partie 1",
                        questions: [
                            {
                                question: "Quelle est la principale source d'énergie d'une éolienne ?",
                                options: ["Le soleil", "Le vent", "L'eau", "La chaleur terrestre"],
                                correctIndex: 1
                            },
                            {
                                question: "Comment appelle-t-on la structure qui supporte l'ensemble d'une éolienne ?",
                                options: ["La nacelle", "Le mât", "Le socle", "Le pilier"],
                                correctIndex: 1
                            },
                            {
                                question: "Quelle partie de l'éolienne capte l'énergie cinétique du vent ?",
                                options: ["Les pales", "L'alternateur", "La nacelle", "Le transformateur"],
                                correctIndex: 0
                            }
                        ]
                    },
                    {
                        title: "Quiz sur les éoliennes - Partie 2",
                        questions: [
                            {
                                question: "Quel type d'énergie est produit par une éolienne ?",
                                options: ["Énergie mécanique", "Énergie nucléaire", "Énergie électrique", "Énergie thermique"],
                                correctIndex: 2
                            },
                            {
                                question: "Quel composant transforme l'énergie mécanique en énergie électrique ?",
                                options: ["Le rotor", "Le multiplicateur", "L'alternateur", "Le convertisseur"],
                                correctIndex: 2
                            },
                            {
                                question: "Comment appelle-t-on l'ensemble formé par le moyeu et les pales ?",
                                options: ["Le rotor", "La turbine", "L'hélice", "Le propulseur"],
                                correctIndex: 0
                            }
                        ]
                    }
                ],
                // Jeux d'association pour les éoliennes
                association: [
                    {
                        title: "Associez les composants à leurs fonctions",
                        pairs: [
                            { term: "Pales", definition: "Captent l'énergie cinétique du vent" },
                            { term: "Nacelle", definition: "Contient les composants de conversion d'énergie" },
                            { term: "Alternateur", definition: "Convertit l'énergie mécanique en électricité" },
                            { term: "Anémomètre", definition: "Mesure la vitesse du vent" },
                            { term: "Girouette", definition: "Détermine la direction du vent" }
                        ]
                    },
                    {
                        title: "Associez les matériaux aux composants",
                        pairs: [
                            { term: "Fibre de verre", definition: "Matériau principal des pales" },
                            { term: "Acier", definition: "Constitue le mât et les renforts structurels" },
                            { term: "Cuivre", definition: "Utilisé dans les bobinages de l'alternateur" },
                            { term: "Béton armé", definition: "Forme les fondations de l'éolienne" },
                            { term: "Fibre de carbone", definition: "Renforce les pales de grande taille" }
                        ]
                    },
                    {
                        title: "Associez les termes techniques aux définitions",
                        pairs: [
                            { term: "Aérogénérateur", definition: "Terme technique désignant une éolienne" },
                            { term: "Parc éolien", definition: "Ensemble d'éoliennes connectées au réseau" },
                            { term: "Offshore", definition: "Éoliennes installées en mer" },
                            { term: "Onshore", definition: "Éoliennes installées sur terre" },
                            { term: "Petit éolien", definition: "Éoliennes de puissance inférieure à 36 kW" }
                        ]
                    }
                ],
                // Jeux du pendu pour les éoliennes
                pendu: [
                    ["PALE", "VENT", "MAT", "ROTOR", "ENERGIE"],
                    ["NACELLE", "TURBINE", "OFFSHORE", "RENOUVELABLE", "MULTIPLICATEUR"]
                ],
                // Memory pour les éoliennes
                memory: [
                    [
                        { key: "Pale", value: "Capte le vent" },
                        { key: "Mât", value: "Supporte la nacelle" },
                        { key: "Rotor", value: "Moyeu et pales" },
                        { key: "Nacelle", value: "Contient le générateur" },
                        { key: "Anémomètre", value: "Mesure le vent" },
                        { key: "Girouette", value: "Direction du vent" },
                        { key: "Alternateur", value: "Produit l'électricité" },
                        { key: "Multiplicateur", value: "Augmente la vitesse" },
                        { key: "Onduleur", value: "Convertit le courant" },
                        { key: "Fondation", value: "Base de l'éolienne" },
                        { key: "Éolien", value: "Énergie du vent" },
                        { key: "Offshore", value: "Éolienne en mer" },
                        { key: "Onshore", value: "Éolienne terrestre" },
                        { key: "Puissance", value: "En watts (W)" },
                        { key: "Vent", value: "Source d'énergie" },
                        { key: "Renouvelable", value: "Type d'énergie" },
                        { key: "Aube", value: "Autre nom de pale" },
                        { key: "kWh", value: "Unité d'énergie" }
                    ]
                ],
                // Mots mêlés pour les éoliennes
                wordsearch: [
                    [
                        "PALE",
                        "VENT",
                        "MAT",
                        "ROTOR",
                        "NACELLE",
                        "ENERGIE",
                        "EOLIEN",
                        "RENOUVELABLE",
                        "TURBINE",
                        "OFFSHORE",
                        "ALTERNATEUR",
                        "GIROUETTE",
                        "ANEMOMETRE"
                    ]
                ]
            },
            fauteuil: {
                // Classification pour les fauteuils électriques
                classification: [
                    {
                        categories: ["Éléments de mobilité", "Système de commande", "Confort et support"],
                        items: [
                            { name: "Roues motrices", category: "Éléments de mobilité" },
                            { name: "Batteries", category: "Éléments de mobilité" },
                            { name: "Joystick", category: "Système de commande" },
                            { name: "Moteurs", category: "Éléments de mobilité" },
                            { name: "Repose-pieds", category: "Confort et support" },
                            { name: "Accoudoirs", category: "Confort et support" },
                            { name: "Unité de contrôle", category: "Système de commande" },
                            { name: "Appui-tête", category: "Confort et support" },
                            { name: "Dossier inclinable", category: "Confort et support" },
                            { name: "Système de freinage", category: "Éléments de mobilité" },
                            { name: "Commande au souffle", category: "Système de commande" },
                            { name: "Gyroscope", category: "Système de commande" }
                        ]
                    }
                ],
                // Chaînes d'énergie et d'information pour les fauteuils électriques
                chaines: [
                    {
                        energie: [
                            "Batteries",
                            "Convertisseur",
                            "Moteurs électriques",
                            "Transmission",
                            "Roues"
                        ],
                        information: [
                            "Joystick",
                            "Commande électronique",
                            "Processeur",
                            "Capteurs",
                            "Réaction système"
                        ]
                    }
                ],
                // Quiz pour les fauteuils électriques
                quiz: [
                    {
                        title: "Quiz sur les fauteuils électriques - Partie 1",
                        questions: [
                            {
                                question: "Quelle est la principale source d'énergie d'un fauteuil électrique ?",
                                options: ["Essence", "Batterie", "Énergie solaire", "Air comprimé"],
                                correctIndex: 1
                            },
                            {
                                question: "Quel composant permet principalement de diriger un fauteuil roulant électrique ?",
                                options: ["Joystick", "Volant", "Pédale", "Levier manuel"],
                                correctIndex: 0
                            },
                            {
                                question: "Combien de roues motrices possède généralement un fauteuil électrique standard ?",
                                options: ["Une", "Deux", "Trois", "Quatre"],
                                correctIndex: 1
                            }
                        ]
                    },
                    {
                        title: "Quiz sur les fauteuils électriques - Partie 2",
                        questions: [
                            {
                                question: "Quel type de batterie est le plus couramment utilisé dans les fauteuils électriques modernes ?",
                                options: ["Plomb-acide", "Nickel-Cadmium", "Lithium-ion", "Alcaline"],
                                correctIndex: 2
                            },
                            {
                                question: "Quelle vitesse maximale peut généralement atteindre un fauteuil électrique standard ?",
                                options: ["5 km/h", "10 km/h", "20 km/h", "30 km/h"],
                                correctIndex: 1
                            },
                            {
                                question: "Quel système permet aux personnes qui ne peuvent pas utiliser leurs mains de contrôler un fauteuil électrique ?",
                                options: ["Commande vocale", "Commande au souffle", "Pédalier", "Commande abdominale"],
                                correctIndex: 1
                            }
                        ]
                    }
                ],
                // Jeux d'association pour les fauteuils électriques
                association: [
                    {
                        title: "Associez les composants à leurs fonctions",
                        pairs: [
                            { term: "Batterie", definition: "Stocke l'énergie électrique" },
                            { term: "Joystick", definition: "Contrôle la direction et la vitesse" },
                            { term: "Moteur", definition: "Convertit l'énergie électrique en mouvement" },
                            { term: "Contrôleur", definition: "Régule la puissance envoyée aux moteurs" },
                            { term: "Roue directrice", definition: "Facilite les changements de direction" }
                        ]
                    },
                    {
                        title: "Associez les matériaux aux composants",
                        pairs: [
                            { term: "Aluminium", definition: "Châssis léger et résistant" },
                            { term: "Mousse haute densité", definition: "Coussins de siège confortables" },
                            { term: "Caoutchouc", definition: "Revêtement des roues pour adhérence" },
                            { term: "Plastique ABS", definition: "Carénages et protections" },
                            { term: "Néoprène", definition: "Revêtement imperméable des commandes" }
                        ]
                    },
                    {
                        title: "Associez les termes techniques aux définitions",
                        pairs: [
                            { term: "Autonomie", definition: "Distance parcourable avec une charge" },
                            { term: "Bascule électrique", definition: "Système modifiant l'inclinaison du siège" },
                            { term: "Traction", definition: "Roues motrices à l'avant" },
                            { term: "Propulsion", definition: "Roues motrices à l'arrière" },
                            { term: "Verticalisation", definition: "Passage de la position assise à debout" }
                        ]
                    }
                ],
                // Jeux du pendu pour les fauteuils électriques
                pendu: [
                    ["ROUE", "SIEGE", "MOTEUR", "BATTERIE", "JOYSTICK"],
                    ["CONTROLLER", "AUTONOMIE", "INCLINAISON", "ASSISTANCE", "ELECTRIQUE"]
                ],
                // Memory pour les fauteuils électriques
                memory: [
                    [
                        { key: "Batterie", value: "Source d'énergie" },
                        { key: "Joystick", value: "Contrôle du fauteuil" },
                        { key: "Moteur", value: "Propulsion" },
                        { key: "Roue motrice", value: "Transmet le mouvement" },
                        { key: "Roulette", value: "Roue directrice" },
                        { key: "Châssis", value: "Structure porteuse" },
                        { key: "Dossier", value: "Support du dos" },
                        { key: "Assise", value: "Support des jambes" },
                        { key: "Repose-pied", value: "Support des pieds" },
                        { key: "Accoudoir", value: "Support des bras" },
                        { key: "Contrôleur", value: "Cerveau électronique" },
                        { key: "Autonomie", value: "Durée d'utilisation" },
                        { key: "Inclinaison", value: "Réglage du dossier" },
                        { key: "Transfert", value: "Changement de siège" },
                        { key: "Appui-tête", value: "Support cervical" },
                        { key: "Ampérage", value: "Intensité électrique" },
                        { key: "Couple", value: "Force de rotation" },
                        { key: "Lithium", value: "Type de batterie" }
                    ]
                ],
                // Mots mêlés pour les fauteuils électriques
                wordsearch: [
                    [
                        "ROUE",
                        "SIEGE",
                        "MOTEUR",
                        "BATTERIE",
                        "JOYSTICK",
                        "CHASSIS",
                        "CONTROLEUR",
                        "ELECTRIQUE",
                        "MOBILITE",
                        "AUTONOMIE",
                        "INCLINAISON",
                        "ASSISTANCE",
                        "CONFORT"
                    ]
                ]
            },
            montre: {
                // Classification pour les montres connectées
                classification: [
                    {
                        categories: ["Capteurs", "Fonctions de communication", "Composants matériels"],
                        items: [
                            { name: "Accéléromètre", category: "Capteurs" },
                            { name: "Cardio-fréquencemètre", category: "Capteurs" },
                            { name: "Bluetooth", category: "Fonctions de communication" },
                            { name: "Wi-Fi", category: "Fonctions de communication" },
                            { name: "Écran tactile", category: "Composants matériels" },
                            { name: "Batterie", category: "Composants matériels" },
                            { name: "GPS", category: "Capteurs" },
                            { name: "NFC", category: "Fonctions de communication" },
                            { name: "Oxymètre", category: "Capteurs" },
                            { name: "Microphone", category: "Composants matériels" },
                            { name: "Haut-parleur", category: "Composants matériels" },
                            { name: "4G/5G", category: "Fonctions de communication" }
                        ]
                    }
                ],
                // Chaînes d'énergie et d'information pour les montres connectées
                chaines: [
                    {
                        energie: [
                            "Batterie",
                            "Circuit d'alimentation",
                            "Processeur",
                            "Capteurs",
                            "Écran"
                        ],
                        information: [
                            "Capteurs de mouvement",
                            "Microcontrôleur",
                            "Algorithmes",
                            "Interface utilisateur",
                            "Application mobile"
                        ]
                    }
                ],
                // Quiz pour les montres connectées
                quiz: [
                    {
                        title: "Quiz sur les montres connectées - Partie 1",
                        questions: [
                            {
                                question: "Quel composant permet à une montre connectée de détecter les mouvements du poignet ?",
                                options: ["Gyroscope", "Accéléromètre", "Magnétomètre", "Baromètre"],
                                correctIndex: 1
                            },
                            {
                                question: "Quelle technologie permet principalement à une montre connectée de communiquer avec un smartphone ?",
                                options: ["Wi-Fi", "Bluetooth", "NFC", "Infrarouge"],
                                correctIndex: 1
                            },
                            {
                                question: "Quel type d'écran est le plus couramment utilisé dans les montres connectées haut de gamme ?",
                                options: ["LCD", "OLED", "E-ink", "Plasma"],
                                correctIndex: 1
                            }
                        ]
                    },
                    {
                        title: "Quiz sur les montres connectées - Partie 2",
                        questions: [
                            {
                                question: "Quel capteur permet de mesurer la fréquence cardiaque ?",
                                options: ["Accéléromètre", "Cardio-fréquencemètre", "GPS", "Altimètre"],
                                correctIndex: 1
                            },
                            {
                                question: "Quelle est l'autonomie moyenne d'une montre connectée standard ?",
                                options: ["1 jour", "2-3 jours", "Une semaine", "Un mois"],
                                correctIndex: 1
                            },
                            {
                                question: "Quelle technologie permet à certaines montres connectées d'effectuer des paiements sans contact ?",
                                options: ["Bluetooth", "Wi-Fi", "NFC", "GPS"],
                                correctIndex: 2
                            }
                        ]
                    }
                ],
                // Jeux d'association pour les montres connectées
                association: [
                    {
                        title: "Associez les composants à leurs fonctions",
                        pairs: [
                            { term: "Accéléromètre", definition: "Détecte les mouvements et l'activité physique" },
                            { term: "GPS", definition: "Localise la position géographique" },
                            { term: "Cardio-fréquencemètre", definition: "Mesure le rythme cardiaque" },
                            { term: "NFC", definition: "Permet les paiements sans contact" },
                            { term: "Bluetooth", definition: "Connecte la montre au smartphone" }
                        ]
                    },
                    {
                        title: "Associez les matériaux aux composants",
                        pairs: [
                            { term: "Verre saphir", definition: "Protection d'écran résistante aux rayures" },
                            { term: "Silicone", definition: "Bracelet souple et imperméable" },
                            { term: "Aluminium", definition: "Boîtier léger et résistant" },
                            { term: "Acier inoxydable", definition: "Boîtier robuste et premium" },
                            { term: "Céramique", definition: "Dos de montre pour les capteurs biométriques" }
                        ]
                    },
                    {
                        title: "Associez les termes techniques aux définitions",
                        pairs: [
                            { term: "Firmware", definition: "Logiciel intégré dans la montre" },
                            { term: "API", definition: "Interface permettant aux applications de communiquer" },
                            { term: "Détection de chute", definition: "Fonction de sécurité pour alerter en cas d'accident" },
                            { term: "ECG", definition: "Fonction médicale avancée de certaines montres" },
                            { term: "eSIM", definition: "Puce permettant la connexion cellulaire sans smartphone" }
                        ]
                    }
                ],
                // Jeux du pendu pour les montres connectées
                pendu: [
                    ["CADRAN", "ECRAN", "TACTILE", "POIGNET", "BLUETOOTH"],
                    ["CONNECTEE", "APPLICATION", "CARDIAQUE", "NOTIFICATION", "SYNCHRONISATION"]
                ],
                // Memory pour les montres connectées
                memory: [
                    [
                        { key: "Écran", value: "Interface visuelle" },
                        { key: "Batterie", value: "Alimentation" },
                        { key: "Bluetooth", value: "Connexion sans fil" },
                        { key: "Cardio", value: "Mesure du cœur" },
                        { key: "GPS", value: "Localisation" },
                        { key: "Accéléromètre", value: "Mesure de mouvement" },
                        { key: "Podomètre", value: "Compteur de pas" },
                        { key: "Gyroscope", value: "Mesure d'orientation" },
                        { key: "Oxymètre", value: "Mesure d'oxygène" },
                        { key: "Bracelet", value: "Attache au poignet" },
                        { key: "Application", value: "Logiciel compagnon" },
                        { key: "Wi-Fi", value: "Connexion internet" },
                        { key: "Notification", value: "Alerte messagerie" },
                        { key: "Étanchéité", value: "Résistance à l'eau" },
                        { key: "NFC", value: "Paiement sans contact" },
                        { key: "Altimètre", value: "Mesure d'altitude" },
                        { key: "Processeur", value: "Cerveau électronique" },
                        { key: "Microphone", value: "Capteur de voix" }
                    ]
                ],
                // Mots mêlés pour les montres connectées
                wordsearch: [
                    [
                        "ECRAN",
                        "TACTILE",
                        "BATTERIE",
                        "BLUETOOTH",
                        "CONNECTEE",
                        "APPLICATION",
                        "CAPTEUR",
                        "CARDIAQUE",
                        "PODOMETRE",
                        "NOTIFICATION",
                        "SYNCHRONISATION",
                        "SPORT",
                        "SANTE"
                    ]
                ]
            }
        };
        
        // Variables globales
        let currentObject = 'eolienne';
        let currentGame = 'quiz';
        
        // Indices pour les jeux avec plusieurs niveaux
        let currentQuizIndex = 0;
        let currentAssociationIndex = 0;
        let currentPenduIndex = 0;
        
        // Suivi de progression
        let gameProgress = {
            eolienne: { quiz: [], association: [], pendu: [], memory: [], motsmeles: [], classification: [], chaines: [] },
            fauteuil: { quiz: [], association: [], pendu: [], memory: [], motsmeles: [], classification: [], chaines: [] },
            montre: { quiz: [], association: [], pendu: [], memory: [], motsmeles: [], classification: [], chaines: [] }
        };
        
        // Initialisation au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            // Activation des onglets pour les objets
            document.querySelectorAll('.object-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const objectId = this.getAttribute('data-object');
                    switchObject(objectId);
                });
            });
            
            // Activation des types de jeux
            document.querySelectorAll('.game-type').forEach(type => {
                type.addEventListener('click', function() {
                    const gameId = this.getAttribute('data-game');
                    switchGame(gameId);
                });
            });
            
            // Activation du mode sombre
            document.querySelector('.dark-toggle').addEventListener('click', function() {
                document.body.classList.toggle('dark-mode');
                
                // Changement de l'icône
                const icon = this.querySelector('i');
                if (document.body.classList.contains('dark-mode')) {
                    icon.className = 'fas fa-sun';
                } else {
                    icon.className = 'fas fa-moon';
                }
            });
            
            // Fonctions de changement d'état
            function switchObject(objectId) {
                // Mise à jour des tabs
                document.querySelectorAll('.object-tab').forEach(tab => {
                    tab.classList.remove('active');
                    if (tab.getAttribute('data-object') === objectId) {
                        tab.classList.add('active');
                    }
                });
                
                // Mise à jour des sections de contenu
                document.querySelectorAll('.content-section').forEach(section => {
                    section.classList.remove('active');
                });
                
                document.getElementById(objectId + '-content').classList.add('active');
                
                currentObject = objectId;
                
                // Réinitialiser les indices
                currentQuizIndex = 0;
                currentAssociationIndex = 0;
                currentPenduIndex = 0;
                
                // Charger le jeu actuel pour ce nouvel objet
                loadGame(currentGame);
            }
            
            function switchGame(gameId) {
                // Mise à jour des tabs
                document.querySelectorAll('.game-type').forEach(type => {
                    type.classList.remove('active');
                    if (type.getAttribute('data-game') === gameId) {
                        type.classList.add('active');
                    }
                });
                
                // Mise à jour des sections de jeu
                document.querySelectorAll('.game-section').forEach(section => {
                    section.classList.remove('active');
                });
                
                const gameSection = document.getElementById(currentObject + '-' + gameId);
                if (gameSection) {
                    gameSection.classList.add('active');
                }
                
                currentGame = gameId;
                loadGame(gameId);
            }
            
            // Chargement des jeux
            function loadGame(gameType) {
                switch(gameType) {
                    case 'quiz':
                        loadQuiz();
                        break;
                    case 'association':
                        loadAssociation();
                        break;
                    case 'pendu':
                        loadPendu();
                        break;
                    case 'memory':
                        loadMemory();
                        break;
                    case 'wordsearch':
                        loadWordsearch();
                        break;
                    case 'classification':
                        loadClassification();
                        break;
                    case 'chaines':
                        loadChaines();
                        break;
                }
            }
            
            // Quiz
            function loadQuiz() {
                const quizData = gameData[currentObject].quiz[currentQuizIndex];
                const quizContainer = document.querySelector(`#${currentObject}-quiz .quiz-container`);
                
                if (!quizData) return;
                
                let quizHtml = '';
                quizData.questions.forEach((q, index) => {
                    quizHtml += `
                        <div class="question-container" data-question="${index}">
                            <div class="question">${index + 1}. ${q.question}</div>
                            <div class="options">
                    `;
                    
                    q.options.forEach((option, optIndex) => {
                        quizHtml += `
                            <div class="option" data-index="${optIndex}">${option}</div>
                        `;
                    });
                    
                    quizHtml += `
                            </div>
                        </div>
                    `;
                });
                
                quizHtml += `
                    <div class="quiz-controls">
                        <button class="btn btn-primary" id="quiz-check">Vérifier mes réponses</button>
                        <button class="btn btn-secondary" id="quiz-next">Quiz suivant</button>
                    </div>
                `;
                
                quizContainer.innerHTML = quizHtml;
                
                // Ajouter les écouteurs d'événements
                document.querySelectorAll(`#${currentObject}-quiz .option`).forEach(option => {
                    option.addEventListener('click', function() {
                        // Désélectionner les autres options dans la même question
                        const questionContainer = this.closest('.question-container');
                        questionContainer.querySelectorAll('.option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        
                        // Sélectionner cette option
                        this.classList.add('selected');
                    });
                });
                
                // Vérification des réponses
                document.getElementById('quiz-check').addEventListener('click', checkQuizAnswers);
                
                // Passage au quiz suivant
                document.getElementById('quiz-next').addEventListener('click', nextQuiz);
                
                // Mise à jour de la barre de progression
                updateProgressBar();
            }
            
            function checkQuizAnswers() {
                const quizData = gameData[currentObject].quiz[currentQuizIndex];
                let allCorrect = true;
                let score = 0;
                
                document.querySelectorAll(`#${currentObject}-quiz .question-container`).forEach((question, qIndex) => {
                    const selectedOption = question.querySelector('.option.selected');
                    const correctIndex = quizData.questions[qIndex].correctIndex;
                    
                    if (selectedOption) {
                        const selectedIndex = parseInt(selectedOption.getAttribute('data-index'));
                        
                        if (selectedIndex === correctIndex) {
                            selectedOption.classList.add('correct');
                            score++;
                        } else {
                            selectedOption.classList.add('incorrect');
                            allCorrect = false;
                            
                            // Montrer la bonne réponse
                            question.querySelectorAll('.option').forEach((opt, optIndex) => {
                                if (optIndex === correctIndex) {
                                    opt.classList.add('correct');
                                }
                            });
                        }
                    } else {
                        allCorrect = false;
                        
                        // Montrer la bonne réponse
                        question.querySelectorAll('.option').forEach((opt, optIndex) => {
                            if (optIndex === correctIndex) {
                                opt.classList.add('correct');
                            }
                        });
                    }
                });
                
                if (allCorrect) {
                    markGameCompleted('quiz', currentObject, currentQuizIndex);
                    document.querySelector('.success-message').style.display = 'block';
                }
                
                // Mise à jour de la barre de progression
                updateProgressBar();
            }
            
            function nextQuiz() {
                document.querySelector('.success-message').style.display = 'none';
                currentQuizIndex = (currentQuizIndex + 1) % gameData[currentObject].quiz.length;
                loadQuiz();
            }
            
            function markGameCompleted(gameType, objectType, gameIndex) {
                if (!gameProgress[objectType][gameType].includes(gameIndex)) {
                    gameProgress[objectType][gameType].push(gameIndex);
                    
                    // Mise à jour de la barre de progression
                    updateProgressBar();
                }
            }
            
            // Mise à jour de la barre de progression
            function updateProgressBar() {
                const progressBar = document.querySelector('.progress-bar');
                
                // Calculer le nombre total de jeux
                const totalGames = Object.keys(gameData).reduce((total, obj) => {
                    return total + Object.keys(gameData[obj]).reduce((objTotal, game) => {
                        return objTotal + (Array.isArray(gameData[obj][game]) ? gameData[obj][game].length : 0);
                    }, 0);
                }, 0);
                
                // Calculer le nombre de jeux complétés
                const completedGames = Object.keys(gameProgress).reduce((total, obj) => {
                    return total + Object.keys(gameProgress[obj]).reduce((objTotal, game) => {
                        return objTotal + (Array.isArray(gameProgress[obj][game]) ? gameProgress[obj][game].length : 0);
                    }, 0);
                }, 0);
                
                // Calculer le pourcentage de progression
                const completionPercent = Math.round((completedGames / totalGames) * 100) || 0;
                
                // Mettre à jour la barre de progression
                progressBar.style.width = `${completionPercent}%`;
                progressBar.setAttribute('aria-valuenow', completionPercent);
                
                // Mettre à jour le texte de progression
                progressBar.setAttribute('title', `${completionPercent}% complété`);
            }
            
            // Association
            function loadAssociation() {
                const associationData = gameData[currentObject].association[currentAssociationIndex];
                const container = document.querySelector(`#${currentObject}-association .association-container`);
                
                if (!associationData) return;
                
                let terms = associationData.pairs.map(p => p.term);
                let definitions = associationData.pairs.map(p => p.definition);
                
                // Mélanger les termes et définitions
                terms = shuffleArray(terms);
                definitions = shuffleArray(definitions);
                
                let associationHtml = `
                    <div class="association-title" style="width: 100%; text-align: center; margin-bottom: 20px;">
                        <h3>${associationData.title}</h3>
                    </div>
                    <div class="term-container" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; width: 100%;">
                `;
                
                terms.forEach(term => {
                    associationHtml += `
                        <div class="term-card" data-term="${term}">${term}</div>
                    `;
                });
                
                associationHtml += `
                    </div>
                    <div class="definition-container" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; width: 100%; margin-top: 30px;">
                `;
                
                definitions.forEach(def => {
                    associationHtml += `
                        <div class="definition-card" data-definition="${def}">${def}</div>
                    `;
                });
                
                associationHtml += `
                    </div>
                    <div style="width: 100%; display: flex; justify-content: space-between; margin-top: 30px;">
                        <button class="btn btn-primary" id="association-reset">Réinitialiser</button>
                        <button class="btn btn-secondary" id="association-next">Jeu suivant</button>
                    </div>
                `;
                
                container.innerHTML = associationHtml;
                
                // Variables pour suivre les sélections
                let selectedTerm = null;
                let selectedDef = null;
                
                // Ajouter les écouteurs d'événements pour les termes
                document.querySelectorAll(`#${currentObject}-association .term-card`).forEach(term => {
                    term.addEventListener('click', function() {
                        if (this.classList.contains('matched')) return;
                        
                        // Désélectionner le terme précédent s'il y en a un
                        if (selectedTerm) selectedTerm.classList.remove('selected');
                        
                        // Sélectionner ce terme
                        this.classList.add('selected');
                        selectedTerm = this;
                        
                        // Vérifier si une paire peut être formée
                        checkForMatch();
                    });
                });
                
                // Ajouter les écouteurs d'événements pour les définitions
                document.querySelectorAll(`#${currentObject}-association .definition-card`).forEach(def => {
                    def.addEventListener('click', function() {
                        if (this.classList.contains('matched')) return;
                        
                        // Désélectionner la définition précédente s'il y en a une
                        if (selectedDef) selectedDef.classList.remove('selected');
                        
                        // Sélectionner cette définition
                        this.classList.add('selected');
                        selectedDef = this;
                        
                        // Vérifier si une paire peut être formée
                        checkForMatch();
                    });
                });
                
                // Vérifier si une paire correcte est formée
                function checkForMatch() {
                    if (!selectedTerm || !selectedDef) return;
                    
                    const termValue = selectedTerm.getAttribute('data-term');
                    const defValue = selectedDef.getAttribute('data-definition');
                    
                    // Trouver la paire correspondante
                    const match = associationData.pairs.find(pair => 
                        pair.term === termValue && pair.definition === defValue);
                    
                    if (match) {
                        // Marquer comme correspondant
                        selectedTerm.classList.remove('selected');
                        selectedTerm.classList.add('matched');
                        
                        selectedDef.classList.remove('selected');
                        selectedDef.classList.add('matched');
                        
                        selectedTerm = null;
                        selectedDef = null;
                        
                        // Vérifier si toutes les paires sont trouvées
                        checkAllMatched();
                    }
                }
                
                // Vérifier si toutes les paires sont trouvées
                function checkAllMatched() {
                    const allTerms = document.querySelectorAll(`#${currentObject}-association .term-card`);
                    const matchedTerms = document.querySelectorAll(`#${currentObject}-association .term-card.matched`);
                    
                    if (allTerms.length === matchedTerms.length) {
                        markGameCompleted('association', currentObject, currentAssociationIndex);
                        document.querySelector('.success-message').style.display = 'block';
                    }
                }
                
                // Réinitialiser le jeu
                document.getElementById('association-reset').addEventListener('click', function() {
                    document.querySelector('.success-message').style.display = 'none';
                    loadAssociation();
                });
                
                // Passer au jeu suivant
                document.getElementById('association-next').addEventListener('click', function() {
                    document.querySelector('.success-message').style.display = 'none';
                    currentAssociationIndex = (currentAssociationIndex + 1) % gameData[currentObject].association.length;
                    loadAssociation();
                });
                
                // Mise à jour de la barre de progression
                updateProgressBar();
            }
            
            // Pendu
            function loadPendu() {
                const penduWords = gameData[currentObject].pendu[currentPenduIndex];
                const container = document.querySelector(`#${currentObject}-pendu .hangman-container`);
                
                if (!penduWords) return;
                
                // Choisir un mot au hasard
                const wordToGuess = penduWords[Math.floor(Math.random() * penduWords.length)];
                
                // Initialiser l'état du jeu
                const penduGameState = {
                    word: wordToGuess,
                    guessed: Array(wordToGuess.length).fill(false),
                    wrongGuesses: 0,
                    maxWrongGuesses: 7, // Nombre de parties du pendu
                    lettersUsed: []
                };
                
                // Créer le HTML pour le jeu
                let penduHtml = `
                    <div class="hangman-word">
                `;
                
                for (let i = 0; i < wordToGuess.length; i++) {
                    penduHtml += `
                        <div class="hangman-letter" data-index="${i}"></div>
                    `;
                }
                
                penduHtml += `
                    </div>
                    
                    <div class="hangman-drawing">
                        <svg width="200" height="250" viewBox="0 0 200 250">
                            <!-- Potence -->
                            <line x1="40" y1="230" x2="160" y2="230" stroke="#333" stroke-width="4"/>
                            <line x1="60" y1="230" x2="60" y2="30" stroke="#333" stroke-width="4"/>
                            <line x1="60" y1="30" x2="140" y2="30" stroke="#333" stroke-width="4"/>
                            <line x1="140" y1="50" x2="140" y2="80" stroke="#333" stroke-width="3" class="hangman-part" id="rope" style="display: none;"/>
                            <!-- Tête -->
                            <circle cx="140" cy="100" r="20" stroke="#333" stroke-width="3" fill="none" class="hangman-part" id="head" style="display: none;"/>
                            <!-- Corps -->
                            <line x1="140" y1="120" x2="140" y2="170" stroke="#333" stroke-width="3" class="hangman-part" id="body" style="display: none;"/>
                            <!-- Bras gauche -->
                            <line x1="140" y1="135" x2="120" y2="120" stroke="#333" stroke-width="3" class="hangman-part" id="left-arm" style="display: none;"/>
                            <!-- Bras droit -->
                            <line x1="140" y1="135" x2="160" y2="120" stroke="#333" stroke-width="3" class="hangman-part" id="right-arm" style="display: none;"/>
                            <!-- Jambe gauche -->
                            <line x1="140" y1="170" x2="120" y2="200" stroke="#333" stroke-width="3" class="hangman-part" id="left-leg" style="display: none;"/>
                            <!-- Jambe droite -->
                            <line x1="140" y1="170" x2="160" y2="200" stroke="#333" stroke-width="3" class="hangman-part" id="right-leg" style="display: none;"/>
                        </svg>
                    </div>
                    
                    <div class="hangman-keyboard">
                `;
                
                // Générer le clavier
                const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                for (let letter of letters) {
                    penduHtml += `
                        <div class="keyboard-key" data-letter="${letter}">${letter}</div>
                    `;
                }
                
                penduHtml += `
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; margin-top: 30px; width: 100%;">
                        <button class="btn btn-primary" id="pendu-reset">Nouveau mot</button>
                        <button class="btn btn-secondary" id="pendu-next">Jeu suivant</button>
                    </div>
                `;
                
                container.innerHTML = penduHtml;
                
                // Ajouter les écouteurs d'événements pour les touches du clavier
                document.querySelectorAll(`#${currentObject}-pendu .keyboard-key`).forEach(key => {
                    key.addEventListener('click', function() {
                        const letter = this.getAttribute('data-letter');
                        makeGuess(letter);
                    });
                });
                
                // Fonction pour faire une supposition
                function makeGuess(letter) {
                    // Si la lettre a déjà été utilisée ou le jeu est terminé, ne rien faire
                    if (penduGameState.lettersUsed.includes(letter) || 
                        penduGameState.wrongGuesses >= penduGameState.maxWrongGuesses ||
                        penduGameState.guessed.every(g => g === true)) {
                        return;
                    }
                    
                    // Marquer la lettre comme utilisée
                    penduGameState.lettersUsed.push(letter);
                    document.querySelector(`#${currentObject}-pendu .keyboard-key[data-letter="${letter}"]`).classList.add('used');
                    
                    // Vérifier si la lettre est dans le mot
                    let found = false;
                    for (let i = 0; i < penduGameState.word.length; i++) {
                        if (penduGameState.word[i] === letter) {
                            penduGameState.guessed[i] = true;
                            document.querySelector(`#${currentObject}-pendu .hangman-letter[data-index="${i}"]`).textContent = letter;
                            found = true;
                        }
                    }
                    
                    // Si la lettre n'est pas dans le mot, incrémenter les erreurs
                    if (!found) {
                        penduGameState.wrongGuesses++;
                        
                        // Afficher la partie correspondante du pendu
                        const parts = ['rope', 'head', 'body', 'left-arm', 'right-arm', 'left-leg', 'right-leg'];
                        if (penduGameState.wrongGuesses <= parts.length) {
                            document.getElementById(parts[penduGameState.wrongGuesses-1]).style.display = 'block';
                        }
                        
                        if (penduGameState.wrongGuesses >= parts.length) {
                            // Jeu perdu, révéler le mot
                            for (let i = 0; i < penduGameState.word.length; i++) {
                                if (!penduGameState.guessed[i]) {
                                    document.querySelector(`#${currentObject}-pendu .hangman-letter[data-index="${i}"]`).textContent = penduGameState.word[i];
                                    document.querySelector(`#${currentObject}-pendu .hangman-letter[data-index="${i}"]`).style.color = 'red';
                                }
                            }
                        }
                    }
                    
                    // Vérifier si le jeu est gagné
                    if (penduGameState.guessed.every(g => g === true)) {
                        markGameCompleted('pendu', currentObject, currentPenduIndex);
                        document.querySelector('.success-message').style.display = 'block';
                    }
                }
                
                // Réinitialiser le jeu
                document.getElementById('pendu-reset').addEventListener('click', function() {
                    document.querySelector('.success-message').style.display = 'none';
                    loadPendu();
                });
                
                // Passer au jeu suivant
                document.getElementById('pendu-next').addEventListener('click', function() {
                    document.querySelector('.success-message').style.display = 'none';
                    currentPenduIndex = (currentPenduIndex + 1) % gameData[currentObject].pendu.length;
                    loadPendu();
                });
                
                // Mise à jour de la barre de progression
                updateProgressBar();
            }
            
            // Memory
            function loadMemory() {
                const memoryData = gameData[currentObject].memory[0]; // Une seule liste par objet
                const container = document.querySelector(`#${currentObject}-memory .memory-container`);
                
                if (!memoryData) return;
                
                // Créer les paires
                let cards = [];
                memoryData.forEach(pair => {
                    cards.push({ id: cards.length, content: pair.key, pairId: pair.key });
                    cards.push({ id: cards.length, content: pair.value, pairId: pair.key });
                });
                
                // Limiter à 18 paires (36 cartes)
                cards = cards.slice(0, 36);
                
                // Mélanger les cartes
                cards = shuffleArray(cards);
                
                // Créer le HTML pour le memory
                let memoryHtml = `
                    <div class="memory-grid">
                `;
                
                cards.forEach(card => {
                    memoryHtml += `
                        <div class="memory-card" data-id="${card.id}" data-pair="${card.pairId}">
                            <div class="front">${card.content}</div>
                            <div class="back">?</div>
                        </div>
                    `;
                });
                
                memoryHtml += `
                    </div>
                    <div style="grid-column: 1 / -1; display: flex; justify-content: space-between; margin-top: 30px;">
                        <button class="btn btn-primary" id="memory-reset">Recommencer</button>
                    </div>
                    <div class="score-display" id="memory-score" style="grid-column: 1 / -1;"></div>
                `;
                
                container.innerHTML = memoryHtml;
                
                // Variables pour suivre le jeu
                let flippedCards = [];
                let matchedPairs = 0;
                let moves = 0;
                let canFlip = true;
                
                // Mettre à jour le score
                updateMemoryScore();
                
                // Ajouter les écouteurs d'événements pour les cartes
                document.querySelectorAll(`#${currentObject}-memory .memory-card`).forEach(card => {
                    card.addEventListener('click', function() {
                        // Si la carte est déjà retournée ou on ne peut pas retourner, ne rien faire
                        if (this.classList.contains('flipped') || !canFlip) return;
                        
                        // Retourner la carte
                        this.classList.add('flipped');
                        
                        // Ajouter à la liste des cartes retournées
                        flippedCards.push(this);
                        
                        // Si deux cartes sont retournées, vérifier si elles forment une paire
                        if (flippedCards.length === 2) {
                            moves++;
                            updateMemoryScore();
                            
                            const pairId1 = flippedCards[0].getAttribute('data-pair');
                            const pairId2 = flippedCards[1].getAttribute('data-pair');
                            
                            if (pairId1 === pairId2) {
                                // C'est une paire !
                                matchedPairs++;
                                flippedCards = [];
                                
                                // Vérifier si toutes les paires sont trouvées
                                if (matchedPairs === cards.length / 2) {
                                    markGameCompleted('memory', currentObject, 0);
                                    document.querySelector('.success-message').style.display = 'block';
                                }
                            } else {
                                // Ce n'est pas une paire, retourner les cartes
                                canFlip = false;
                                setTimeout(() => {
                                    flippedCards[0].classList.remove('flipped');
                                    flippedCards[1].classList.remove('flipped');
                                    flippedCards = [];
                                    canFlip = true;
                                }, 1000);
                            }
                        }
                    });
                });
                
                // Mettre à jour l'affichage du score
                function updateMemoryScore() {
                    const scoreDisplay = document.getElementById('memory-score');
                    scoreDisplay.textContent = `Coups : ${moves} | Paires trouvées : ${matchedPairs}/${cards.length/2}`;
                }
                
                // Réinitialiser le jeu
                document.getElementById('memory-reset').addEventListener('click', function() {
                    document.querySelector('.success-message').style.display = 'none';
                    loadMemory();
                });
                
                // Mise à jour de la barre de progression
                updateProgressBar();
            }
            
            // Mots mêlés
            function loadWordsearch() {
                const wordsList = gameData[currentObject].wordsearch[0]; // Une seule liste par objet
                const container = document.querySelector(`#${currentObject}-wordsearch .wordsearch-container`);
                
                if (!wordsList) return;
                
                // Initialiser la grille (15x15)
                const gridSize = 15;
                let grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));
                
                // Placer les mots dans la grille
                const directions = [
                    [0, 1],  // Horizontal (droite)
                    [1, 0],  // Vertical (bas)
                    [1, 1],  // Diagonal (bas-droite)
                    [1, -1], // Diagonal (bas-gauche)
                    [0, -1], // Horizontal (gauche)
                    [-1, 0], // Vertical (haut)
                    [-1, -1], // Diagonal (haut-gauche)
                    [-1, 1]   // Diagonal (haut-droite)
                ];
                
                let placedWords = [];
                
                for (let word of wordsList) {
                    // Essayer de placer le mot plusieurs fois
                    let placed = false;
                    let attempts = 0;
                    const maxAttempts = 100;
                    
                    while (!placed && attempts < maxAttempts) {
                        attempts++;
                        
                        // Choisir une direction aléatoire
                        const dir = directions[Math.floor(Math.random() * directions.length)];
                        
                        // Position de départ aléatoire
                        const startRow = Math.floor(Math.random() * gridSize);
                        const startCol = Math.floor(Math.random() * gridSize);
                        
                        // Vérifier si le mot peut être placé
                        let canPlace = true;
                        
                        // Vérifier les limites de la grille
                        const endRow = startRow + dir[0] * (word.length - 1);
                        const endCol = startCol + dir[1] * (word.length - 1);
                        
                        if (endRow < 0 || endRow >= gridSize || endCol < 0 || endCol >= gridSize) {
                            canPlace = false;
                            continue;
                        }
                        
                        // Vérifier si le placement du mot est valide
                        for (let i = 0; i < word.length; i++) {
                            const row = startRow + dir[0] * i;
                            const col = startCol + dir[1] * i;
                            
                            if (grid[row][col] !== '' && grid[row][col] !== word[i]) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        // Placer le mot si possible
                        if (canPlace) {
                            for (let i = 0; i < word.length; i++) {
                                const row = startRow + dir[0] * i;
                                const col = startCol + dir[1] * i;
                                grid[row][col] = word[i];
                            }
                            
                            placed = true;
                            placedWords.push(word);
                        }
                    }
                }
                
                // Remplir les cases vides avec des lettres aléatoires
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (grid[i][j] === '') {
                            grid[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26)); // A-Z
                        }
                    }
                }
                
                let wordsearchHtml = `
                    <div class="wordsearch-grid">
                `;
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        wordsearchHtml += `
                            <div class="wordsearch-cell" data-row="${i}" data-col="${j}">${grid[i][j]}</div>
                        `;
                    }
                }
                
                wordsearchHtml += `
                    </div>
                    
                    <div class="wordsearch-words">
                `;
                
                for (let word of placedWords) {
                    wordsearchHtml += `
                        <div class="wordsearch-word" data-word="${word}">${word}</div>
                    `;
                }
                
                wordsearchHtml += `
                    </div>
                    
                    <div style="width: 100%; display: flex; justify-content: space-between; margin-top: 30px;">
                        <button class="btn btn-primary" id="wordsearch-reset">Réinitialiser</button>
                    </div>
                `;
                
                container.innerHTML = wordsearchHtml;
                
                // Variables pour suivre la sélection
                let selectedCells = [];
                let foundWords = [];
                
                // Ajouter les écouteurs d'événements pour les cellules
                document.querySelectorAll(`#${currentObject}-wordsearch .wordsearch-cell`).forEach(cell => {
                    cell.addEventListener('mousedown', startSelection);
                    cell.addEventListener('mouseover', continueSelection);
                    cell.addEventListener('mouseup', endSelection);
                });
                
                // Désactiver la sélection de texte pendant le drag
                document.querySelector(`#${currentObject}-wordsearch .wordsearch-grid`).addEventListener('selectstart', function(e) {
                    e.preventDefault();
                });
                
                // Fonction pour commencer la sélection
                function startSelection() {
                    // Réinitialiser la sélection précédente
                    selectedCells.forEach(cell => {
                        if (!cell.classList.contains('found')) {
                            cell.classList.remove('selected');
                        }
                    });
                    selectedCells = [];
                    
                    // Sélectionner cette cellule
                    if (!this.classList.contains('found')) {
                        this.classList.add('selected');
                    }
                    selectedCells.push(this);
                    
                    // Activer la sélection
                    document.addEventListener('mouseup', endSelection);
                }
                
                // Fonction pour continuer la sélection
                function continueSelection() {
                    // Ignorer si la sélection n'a pas commencé
                    if (selectedCells.length === 0) return;
                    
                    // Vérifier si cette cellule est adjacente à la dernière cellule sélectionnée
                    const lastCell = selectedCells[selectedCells.length - 1];
                    const lastRow = parseInt(lastCell.getAttribute('data-row'));
                    const lastCol = parseInt(lastCell.getAttribute('data-col'));
                    const currentRow = parseInt(this.getAttribute('data-row'));
                    const currentCol = parseInt(this.getAttribute('data-col'));
                    
                    // Vérifier si c'est la même direction que la sélection en cours
                    if (selectedCells.length > 1) {
                        const firstCell = selectedCells[0];
                        const firstRow = parseInt(firstCell.getAttribute('data-row'));
                        const firstCol = parseInt(firstCell.getAttribute('data-col'));
                        
                        const dirRow = (lastRow - firstRow) / (selectedCells.length - 1);
                        const dirCol = (lastCol - firstCol) / (selectedCells.length - 1);
                        
                        const newDirRow = currentRow - lastRow;
                        const newDirCol = currentCol - lastCol;
                        
                        // Si ce n'est pas la même direction ou pas adjacent, ignorer
                        if (Math.abs(newDirRow) > 1 || Math.abs(newDirCol) > 1 || 
                            (dirRow !== 0 && newDirRow !== dirRow) || 
                            (dirCol !== 0 && newDirCol !== dirCol)) {
                            return;
                        }
                    } else {
                        // Pour la première extension, vérifier juste si c'est adjacent
                        if (Math.abs(currentRow - lastRow) > 1 || Math.abs(currentCol - lastCol) > 1) {
                            return;
                        }
                    }
                    
                    // Si cette cellule est déjà sélectionnée, ignorer
                    if (selectedCells.includes(this)) return;
                    
                    // Ajouter à la sélection
                    if (!this.classList.contains('found')) {
                        this.classList.add('selected');
                    }
                    selectedCells.push(this);
                }
                
                // Fonction pour terminer la sélection
                function endSelection() {
                    // Vérifier si la sélection forme un mot
                    let selectedWord = '';
                    selectedCells.forEach(cell => {
                        selectedWord += cell.textContent;
                    });
                    
                    // Vérifier si le mot est dans la liste
                    const wordElement = document.querySelector(`#${currentObject}-wordsearch .wordsearch-word[data-word="${selectedWord}"]`);
                    
                    if (wordElement && !foundWords.includes(selectedWord)) {
                        // Mot trouvé !
                        foundWords.push(selectedWord);
                        
                        // Marquer les cellules comme trouvées
                        selectedCells.forEach(cell => {
                            cell.classList.remove('selected');
                            cell.classList.add('found');
                        });
                        
                        // Marquer le mot comme trouvé
                        wordElement.classList.add('found');
                        
                        // Vérifier si tous les mots sont trouvés
                        if (foundWords.length === placedWords.length) {
                            markGameCompleted('wordsearch', currentObject, 0);
                            document.querySelector('.success-message').style.display = 'block';
                        }
                    } else {
                        // Ce n'est pas un mot valide, réinitialiser la sélection
                        selectedCells.forEach(cell => {
                            if (!cell.classList.contains('found')) {
                                cell.classList.remove('selected');
                            }
                        });
                    }
                    
                    // Réinitialiser la sélection
                    selectedCells = [];
                    
                    // Désactiver la sélection
                    document.removeEventListener('mouseup', endSelection);
                }
                
                // Réinitialiser le jeu
                document.getElementById('wordsearch-reset').addEventListener('click', function() {
                    document.querySelector('.success-message').style.display = 'none';
                    loadWordsearch();
                });
                
                // Mise à jour de la barre de progression
                updateProgressBar();
            }
            
            // Classification
            function loadClassification() {
                const classificationData = gameData[currentObject].classification[0]; // Une seule classification par objet
                const container = document.querySelector(`#${currentObject}-classification .classification-container`);
                
                if (!classificationData) return;
                
                let classificationHtml = `
                    <h3 style="text-align: center; margin-bottom: 20px;">Classez les éléments dans les bonnes catégories</h3>
                    
                    <div class="classification-categories">
                `;
                
                classificationData.categories.forEach(category => {
                    classificationHtml += `
                        <div class="classification-category" data-category="${category}">
                            <div class="classification-category-title">${category}</div>
                            <div class="classification-category-items" data-category="${category}"></div>
                        </div>
                    `;
                });
                
                classificationHtml += `
                    </div>
                    
                    <div class="classification-items">
                `;
                
                // Mélanger les items
                const shuffledItems = shuffleArray([...classificationData.items]);
                
                shuffledItems.forEach(item => {
                    classificationHtml += `
                        <div class="classification-item" draggable="true" data-name="${item.name}" data-category="${item.category}">${item.name}</div>
                    `;
                });
                
                classificationHtml += `
                    </div>
                    
                    <div style="width: 100%; display: flex; justify-content: space-between; margin-top: 30px;">
                        <button class="btn btn-primary" id="classification-reset">Réinitialiser</button>
                        <button class="btn btn-primary" id="classification-check">Vérifier</button>
                    </div>
                `;
                
                container.innerHTML = classificationHtml;
                
                // Ajouter les écouteurs d'événements pour le drag and drop
                let draggedItem = null;
                
                // Éléments à classer
                document.querySelectorAll(`#${currentObject}-classification .classification-item`).forEach(item => {
                    item.addEventListener('dragstart', function(e) {
                        draggedItem = this;
                        setTimeout(() => {
                            this.classList.add('dragging');
                        }, 0);
                    });
                    
                    item.addEventListener('dragend', function() {
                        this.classList.remove('dragging');
                    });
                });
                
                // Catégories
                document.querySelectorAll(`#${currentObject}-classification .classification-category`).forEach(category => {
                    category.addEventListener('dragover', function(e) {
                        e.preventDefault();
                        this.classList.add('highlight');
                    });
                    
                    category.addEventListener('dragleave', function() {
                        this.classList.remove('highlight');
                    });
                    
                    category.addEventListener('drop', function(e) {
                        e.preventDefault();
                        this.classList.remove('highlight');
                        
                        if (draggedItem) {
                            // Ajouter l'élément à cette catégorie
                            const categoryItems = this.querySelector('.classification-category-items');
                            categoryItems.appendChild(draggedItem);
                            draggedItem.classList.add('placed');
                            draggedItem.setAttribute('draggable', 'false');
                            
                            draggedItem = null;
                            
                            // Vérifier si tous les éléments sont classés
                            checkAllClassified();
                        }
                    });
                });
                
                // Vérifier si tous les éléments sont classés
                function checkAllClassified() {
                    const unclassifiedItems = document.querySelectorAll(`#${currentObject}-classification .classification-item:not(.placed)`);
                    
                    if (unclassifiedItems.length === 0) {
                        // Tous les éléments sont classés
                        document.getElementById('classification-check').disabled = false;
                    }
                }
                
                // Vérifier les réponses
                document.getElementById('classification-check').addEventListener('click', function() {
                    let allCorrect = true;
                    
                    document.querySelectorAll(`#${currentObject}-classification .classification-category`).forEach(category => {
                        const categoryName = category.getAttribute('data-category');
                        const items = category.querySelectorAll('.classification-item');
                        
                        items.forEach(item => {
                            const correctCategory = item.getAttribute('data-category');
                            
                            if (correctCategory === categoryName) {
                                item.style.backgroundColor = 'var(--secondary)';
                                item.style.color = 'white';
                            } else {
                                item.style.backgroundColor = 'var(--accent)';
                                item.style.color = 'white';
                                allCorrect = false;
                            }
                        });
                    });
                    
                    if (allCorrect) {
                        markGameCompleted('classification', currentObject, 0);
                        document.querySelector('.success-message').style.display = 'block';
                    }
                });
                
                // Réinitialiser le jeu
                document.getElementById('classification-reset').addEventListener('click', function() {
                    document.querySelector('.success-message').style.display = 'none';
                    loadClassification();
                });
                
                // Mise à jour de la barre de progression
                updateProgressBar();
            }
            
            // Chaînes
            function loadChaines() {
                const chainesData = gameData[currentObject].chaines[0]; // Une seule chaîne par objet
                const container = document.querySelector(`#${currentObject}-chaines .chaines-container`);
                
                if (!chainesData) return;
                
                let chainesHtml = `
                    <div class="chaine-diagram">
                        <div class="chaine-title">Chaîne d'Énergie</div>
                        <div class="chaine-blocks" id="energie-chain">
                `;
                
                for (let i = 0; i < chainesData.energie.length; i++) {
                    chainesHtml += `
                        <div class="chaine-block energie-block" data-position="${i}" data-answer="${chainesData.energie[i]}"></div>
                    `;
                    
                    if (i < chainesData.energie.length - 1) {
                        chainesHtml += `<div class="chaine-arrow"></div>`;
                    }
                }
                
                chainesHtml += `
                        </div>
                    </div>
                    
                    <div class="chaine-diagram">
                        <div class="chaine-title">Chaîne d'Information</div>
                        <div class="chaine-blocks" id="information-chain">
                `;
                
                for (let i = 0; i < chainesData.information.length; i++) {
                    chainesHtml += `
                        <div class="chaine-block information-block" data-position="${i}" data-answer="${chainesData.information[i]}"></div>
                    `;
                    
                    if (i < chainesData.information.length - 1) {
                        chainesHtml += `<div class="chaine-arrow"></div>`;
                    }
                }
                
                chainesHtml += `
                        </div>
                    </div>
                    
                    <div class="chaine-options">
                `;
                
                // Mélanger les options
                const allOptions = [...chainesData.energie, ...chainesData.information];
                const shuffledOptions = shuffleArray([...allOptions]);
                
                shuffledOptions.forEach(option => {
                    chainesHtml += `
                        <div class="chaine-option" data-value="${option}">${option}</div>
                    `;
                });
                
                chainesHtml += `
                    </div>
                    
                    <div style="width: 100%; display: flex; justify-content: space-between; margin-top: 30px;">
                        <button class="btn btn-primary" id="chaines-reset">Réinitialiser</button>
                        <button class="btn btn-primary" id="chaines-check">Vérifier</button>
                    </div>
                `;
                
                container.innerHTML = chainesHtml;
                
                // Variables pour suivre les sélections
                let selectedBlock = null;
                let placedOptions = [];
                
                // Ajouter les écouteurs d'événements pour les blocs de chaîne
                document.querySelectorAll(`#${currentObject}-chaines .chaine-block`).forEach(block => {
                    block.addEventListener('click', function() {
                        // Désélectionner le bloc précédent s'il y en a un
                        if (selectedBlock) selectedBlock.classList.remove('highlight');
                        
                        // Sélectionner ce bloc
                        this.classList.add('highlight');
                        selectedBlock = this;
                    });
                });
                
                // Ajouter les écouteurs d'événements pour les options
                document.querySelectorAll(`#${currentObject}-chaines .chaine-option`).forEach(option => {
                    option.addEventListener('click', function() {
                        // Si une option a déjà été placée ou aucun bloc n'est sélectionné, ne rien faire
                        if (this.classList.contains('used') || !selectedBlock) return;
                        
                        // Placer l'option dans le bloc sélectionné
                        const optionValue = this.getAttribute('data-value');
                        selectedBlock.textContent = optionValue;
                        selectedBlock.setAttribute('data-value', optionValue);
                        
                        // Marquer cette option comme utilisée
                        this.classList.add('used');
                        placedOptions.push(optionValue);
                        
                        // Désélectionner le bloc
                        selectedBlock.classList.remove('highlight');
                        selectedBlock = null;
                        
                        // Vérifier si toutes les options sont placées
                        checkAllPlaced();
                    });
                });
                
                // Vérifier si toutes les options sont placées
                function checkAllPlaced() {
                    const blocks = document.querySelectorAll(`#${currentObject}-chaines .chaine-block`);
                    
                    if (placedOptions.length === blocks.length) {
                        // Toutes les options sont placées, activer le bouton de vérification
                        document.getElementById('chaines-check').disabled = false;
                    }
                }
                
                // Vérifier les réponses
                document.getElementById('chaines-check').addEventListener('click', function() {
                    let allCorrect = true;
                    
                    document.querySelectorAll(`#${currentObject}-chaines .chaine-block`).forEach(block => {
                        const position = block.getAttribute('data-position');
                        const answer = block.getAttribute('data-answer');
                        const value = block.getAttribute('data-value');
                        
                        if (answer === value) {
                            block.style.backgroundColor = 'rgba(46, 204, 113, 0.2)';
                            block.style.borderColor = 'var(--secondary)';
                        } else {
                            block.style.backgroundColor = 'rgba(231, 76, 60, 0.2)';
                            block.style.borderColor = 'var(--accent)';
                            allCorrect = false;
                        }
                    });
                    
                    if (allCorrect) {
                        markGameCompleted('chaines', currentObject, 0);
                        document.querySelector('.success-message').style.display = 'block';
                    }
                });
                
                // Réinitialiser le jeu
                document.getElementById('chaines-reset').addEventListener('click', function() {
                    document.querySelector('.success-message').style.display = 'none';
                    loadChaines();
                });
                
                // Mise à jour de la barre de progression
                updateProgressBar();
            }
            
            // Fonction pour mélanger un tableau
            function shuffleArray(array) {
                let currentIndex = array.length;
                let temporaryValue, randomIndex;
                
                // Tant qu'il reste des éléments à mélanger
                while (currentIndex !== 0) {
                    // Prendre un élément restant
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex -= 1;
                    
                    // Et l'échanger avec l'élément actuel
                    temporaryValue = array[currentIndex];
                    array[currentIndex] = array[randomIndex];
                    array[randomIndex] = temporaryValue;
                }
                
                return array;
            }
            
            // Bouton de remise à zéro
            document.getElementById('reset-button').addEventListener('click', function() {
                if (confirm('Êtes-vous sûr de vouloir réinitialiser toute votre progression ?')) {
                    // Réinitialiser la progression
                    gameProgress = {
                        eolienne: { quiz: [], association: [], pendu: [], memory: [], motsmeles: [], classification: [], chaines: [] },
                        fauteuil: { quiz: [], association: [], pendu: [], memory: [], motsmeles: [], classification: [], chaines: [] },
                        montre: { quiz: [], association: [], pendu: [], memory: [], motsmeles: [], classification: [], chaines: [] }
                    };
                    
                    // Mettre à jour la barre de progression
                    updateProgressBar();
                    
                    // Masquer le message de succès
                    document.querySelector('.success-message').style.display = 'none';
                    
                    // Recharger le jeu actuel
                    loadGame(currentGame);
                }
            });
            
            // Charger le jeu initial
            loadGame(currentGame);
        });
    </script>

</body>
</html>